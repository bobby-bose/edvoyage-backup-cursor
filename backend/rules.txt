ğŸŒŸ GENERAL PRINCIPLES
---------------------------
1. Code MUST be modular and reusable.
2. Every model, view, serializer, and utility MUST be documented.
3. No hardcoded values; use settings.py or constants.
4. Each feature MUST reside in its own app (e.g., courses/, universities/, quizzes/).
5. All core feature actions (login, post-create, app submission, etc.) MUST have print/log statements in DEV mode to trace flow.
6. Use .env or system config for all sensitive data.

===========================
ğŸ“› NAMING CONVENTIONS
===========================
- Models: PascalCase (e.g., UniversityApplication)
- Fields: snake_case (e.g., created_at, user_email)
- Views: VerbNoun style (e.g., create_course_view)
- URLs: kebab-case (e.g., /api/user-profile/)
- Serializers: Same as model + "Serializer" (e.g., UserProfileSerializer)
- Constants: UPPER_CASE (e.g., MAX_UPLOAD_SIZE_MB)

===========================
ğŸ” CODE REUSABILITY
===========================
1. Create common base classes in `core/` or `common/` app:
   - BaseModel (with created_at, updated_at, soft delete)
   - BaseAPIView (for logging, error handling)
   - BaseSerializer (add custom validations)
2. Use DRF ViewSets and Generic Views wherever possible.
3. Extract shared logic (file upload, validation, pagination) into `utils/`.

===========================
ğŸ› ï¸ DEVELOPER MODE LOGGING
===========================
1. Enable DEVELOPER_MODE in settings.py.
2. If DEVELOPER_MODE is True:
   - Every POST/PUT/DELETE API MUST print payload and status.
   - Every view entry point MUST log "Entering <ViewName>"
   - Every model save() override should print "Saving <ModelName> instance"
3. Use `logger.debug()` or `print()` inside `if settings.DEVELOPER_MODE`.

===========================
ğŸ§¯ EXCEPTION HANDLING
===========================
1. Use try/except in all external API calls, file I/O, and database writes.
2. All try blocks must:
   - Log the exception with context
   - Return a structured error response (do NOT crash)
3. Always include a fallback/default in serializers and views.

Example:
```python
try:
    result = external_call()
except ExternalServiceError as e:
    logger.error(f"Error calling service: {e}")
    return Response({'error': 'Service Unavailable'}, status=503)
===========================
ğŸ” SECURITY BEST PRACTICES
NEVER print tokens or passwords.

JWTs must expire in 24 hours or less.

Use CSRF and CORS properly configured.

User uploads are virus-checked and validated.

===========================
âœ… API STRUCTURE
All APIs must follow: /api/v1/<app_name>/<action>/

Use pagination for any list > 25 items

All POST/PUT APIs must validate input using serializers

Use status codes correctly (200, 201, 400, 403, 404, 500)

Use Response({'success': True, 'data': ...}) as standard response

===========================
ğŸ“‚ FOLDER STRUCTURE
Each app MUST follow this structure:

php-template
Copy
Edit
<app>/
â”œâ”€â”€ models/
â”‚   â””â”€â”€ <feature_model>.py
â”œâ”€â”€ views/
â”‚   â””â”€â”€ <feature_view>.py
â”œâ”€â”€ serializers/
â”‚   â””â”€â”€ <feature_serializer>.py
â”œâ”€â”€ urls.py
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ test_<feature>.py
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ helpers.py
===========================
ğŸ§ª TESTING
100% of views and serializers must have test cases.

Use factory_boy or model_mommy for dummy data.

Each app MUST contain tests/test_*.py.

===========================
ğŸ“Š ANALYTICS HOOKS (Optional)
Add analytics/log events for:

Login success/fail

Application submission

Payment attempt

Quiz started/completed

===========================
ğŸ“ˆ SCALABILITY & FUTURE-PROOFING
Use Celery for background jobs (notifications, analytics)

Use S3 or cloud storage for file uploads

Structure models for multi-tenant scalability if needed


ğŸ“ File-Specific Coding Conventions

===========================
ğŸ”¹ models.py (Models Layer)
Use models.Model as base for all models

All models must include:

created_at and updated_at (auto_now_add, auto_now)

__str__() for readable admin view

Meta class with verbose_name, ordering

âœ… Example

python
Copy
Edit
class Course(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    university = models.ForeignKey('University', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Course"
        ordering = ['-created_at']

    def __str__(self):
        return self.name
âœ… Best Practices

Use choices for enum-type fields

Use related_name in all relationships

Use validators (e.g., MinLengthValidator) where possible

Avoid null=True on CharField and TextField

ğŸ”¹ serializers.py (API Data Layer)
Use ModelSerializer when possible

Add validate_<field>() for field-level validation

Use create() and update() methods for custom logic

Always exclude sensitive fields (password, is_staff)

âœ… Example

python
Copy
Edit
class CourseSerializer(serializers.ModelSerializer):
    class Meta:
        model = Course
        fields = ['id', 'name', 'description', 'university']

    def validate_name(self, value):
        if not value:
            raise serializers.ValidationError("Course name cannot be empty.")
        return value
âœ… Best Practices

Use nested serializers for foreign key/many-to-many

Use depth=1 only for admin/dev debugging

All fields should have read_only or write_only defined if not both

ğŸ”¹ views.py (View Layer / Logic)
Use class-based views (APIView, GenericViewSet, ModelViewSet)

All views must be documented with a short docstring

Return consistent Response() objects with success, data, message

Use try-except in all methods that perform I/O, DB write, or 3rd-party calls

âœ… Example

python
Copy
Edit
class CourseViewSet(viewsets.ModelViewSet):
    queryset = Course.objects.all()
    serializer_class = CourseSerializer
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        print("Creating course") if settings.DEVELOPER_MODE else None
        try:
            return super().create(request, *args, **kwargs)
        except Exception as e:
            logger.error(f"Course creation failed: {e}")
            return Response({'success': False, 'message': 'Internal error'}, status=500)
âœ… Best Practices

Use get_queryset() to filter by current user if needed

Return 404 using get_object_or_404 instead of try/except on .get()

Add pagination on list views if > 25 items

ğŸ”¹ urls.py (Routing Layer)
Use path() or re_path() consistently â€” prefer path() unless regex is needed

Group routes logically per app/module

All paths must follow kebab-case

Versioning must be enforced (api/v1/)

âœ… Example

python
Copy
Edit
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import CourseViewSet

router = DefaultRouter()
router.register(r'courses', CourseViewSet, basename='courses')

urlpatterns = [
    path('api/v1/', include(router.urls)),
]
âœ… Best Practices

Never use string-based view references like 'myapp.views.view_name'

Use named routes (e.g., name='course-list') for reverse lookups

All API routes must be documented in OpenAPI/Swagger if possible

ğŸ”¹ admin.py (Admin Interface)
Use @admin.register(Model) for all models

Include list_display, search_fields, list_filter

Avoid registering models without a custom admin class

âœ… Example

python
Copy
Edit
@admin.register(Course)
class CourseAdmin(admin.ModelAdmin):
    list_display = ('id', 'name', 'university', 'created_at')
    search_fields = ('name',)
    list_filter = ('university',)
ğŸ”¹ apps.py
All apps must have:

python
Copy
Edit
default_auto_field = 'django.db.models.BigAutoField'
App name must match folder exactly

ğŸ”¹ settings.py
Use .env with python-decouple or django-environ

Separate settings into:

base.py, dev.py, prod.py

Developer flags:

python
Copy
Edit
DEVELOPER_MODE = True